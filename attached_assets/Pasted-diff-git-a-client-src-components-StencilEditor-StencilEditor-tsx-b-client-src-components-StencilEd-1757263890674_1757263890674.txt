diff --git a/client/src/components/StencilEditor/StencilEditor.tsx b/client/src/components/StencilEditor/StencilEditor.tsx
index 08d0002581831b066b3e4f58e4d43da6a7f7024b..6b8c96e89a7c43e8bef81983f23d88c9bf84c6aa 100644
--- a/client/src/components/StencilEditor/StencilEditor.tsx
+++ b/client/src/components/StencilEditor/StencilEditor.tsx
@@ -282,137 +282,159 @@ export default function StencilEditor({ originalImage, stencilImage }: StencilEd
   }, [stencilImg, stencilHue]);
 
   // Manejo de gestos táctiles y mouse
   const handleMouseDown = (e: KonvaMouseEvent | KonvaTouchEvent) => {
     const stage = stageRef.current;
     if (!stage) return;
     const pos = stage.getPointerPosition();
     if (!pos) return;
     
     const mouseEvent = e.evt as MouseEvent;
     if (tool === 'move' || mouseEvent.button === 1 || mouseEvent.button === 2) { // Move tool, middle click or right click for panning
       e.evt.preventDefault();
       setIsPanning(true);
       setLastPointerPosition(pos);
       return;
     }
 
     if (tool === 'brush' || tool === 'eraser') {
       // Ignorar gestos de dibujo/borrado si el pointerType es 'touch'
       const pointerEvent = e.evt as any;
       if (pointerEvent.pointerType === 'touch') {
         return;
       }
       setIsDrawing(true);
       const transform = stage.getAbsoluteTransform().copy().invert();
-      const { x, y } = transform.point(pos);
+      const point = transform.point(pos);
+      const x = Math.max(0, Math.min(nativeSize.width, point.x));
+      const y = Math.max(0, Math.min(nativeSize.height, point.y));
 
       // Si es borrador en capa stencil, preparar canvas para edición
       if (tool === 'eraser' && activeLayer === 'stencil' && stencilImg) {
         setIsErasingStencil(true);
         
         // Crear canvas de trabajo si no existe
         if (!stencilCanvas) {
           const canvas = document.createElement('canvas');
           canvas.width = stencilImg.width;
           canvas.height = stencilImg.height;
           const ctx = canvas.getContext('2d');
           if (ctx) {
             ctx.drawImage(stencilImg, 0, 0);
             setStencilCanvas(canvas);
           }
         }
         
         // Aplicar borrado inicial
         if (stencilCanvas) {
           const ctx = stencilCanvas.getContext('2d');
           if (ctx) {
-            ctx.save();
-            ctx.globalCompositeOperation = 'destination-out';
-            ctx.beginPath();
-            ctx.arc(x, y, eraserSize, 0, 2 * Math.PI);
-            ctx.fill();
-            ctx.restore();
+            const radius = Math.min(
+              eraserSize,
+              x,
+              y,
+              nativeSize.width - x,
+              nativeSize.height - y
+            );
+            if (radius > 0) {
+              ctx.save();
+              ctx.globalCompositeOperation = 'destination-out';
+              ctx.beginPath();
+              ctx.arc(x, y, radius, 0, 2 * Math.PI);
+              ctx.fill();
+              ctx.restore();
+            }
           }
         }
         return;
       }
       
       const color = tool === 'brush'
         ? (activeLayer === 'stencil' ? '#ef4444' : brushColor)
         : '#ffffff';
       currentLineRef.current = {
         tool,
         points: [],
         strokeWidth: tool === 'brush' ? brushSize : eraserSize,
         globalCompositeOperation: tool === 'eraser' ? 'destination-out' : 'source-over',
         layer: activeLayer,
         color
       };
       drawingPointsRef.current = [x, y];
       frameRef.current = requestAnimationFrame(updateTempLine);
     }
   };
 
   const handleMouseMove = (e: KonvaMouseEvent | KonvaTouchEvent) => {
     const stage = stageRef.current;
     if (!stage) return;
     const pos = stage.getPointerPosition();
     if (!pos) return;
 
     if (isPanning) {
       const deltaX = pos.x - lastPointerPosition.x;
       const deltaY = pos.y - lastPointerPosition.y;
       handleGesture('pan', { deltaX, deltaY });
       setLastPointerPosition(pos);
       return;
     }
 
     if (!isDrawing) return;
     
     // Ignorar gestos de dibujo/borrado si el pointerType es 'touch'
     const pointerEvent = e.evt as any;
     if (pointerEvent.pointerType === 'touch') {
       return;
     }
     const transform = stage.getAbsoluteTransform().copy().invert();
-    const { x, y } = transform.point(pos);
+    const point = transform.point(pos);
+    const x = Math.max(0, Math.min(nativeSize.width, point.x));
+    const y = Math.max(0, Math.min(nativeSize.height, point.y));
 
     // Si es borrador en capa stencil, usar técnica de borrado inmediato ultra-rápido
     if (tool === 'eraser' && activeLayer === 'stencil' && stencilCanvas && isErasingStencil) {
       const ctx = stencilCanvas.getContext('2d');
       
       if (ctx) {
         // Borrado inmediato sin operaciones bloqueantes
         ctx.globalCompositeOperation = 'destination-out';
         ctx.fillStyle = '#000';
-        
+
         // Borrado instantáneo con mínimo procesamiento
-        ctx.beginPath();
-        ctx.arc(x, y, eraserSize, 0, 2 * Math.PI);
-        ctx.fill();
-        
+        const radius = Math.min(
+          eraserSize,
+          x,
+          y,
+          nativeSize.width - x,
+          nativeSize.height - y
+        );
+        if (radius > 0) {
+          ctx.beginPath();
+          ctx.arc(x, y, radius, 0, 2 * Math.PI);
+          ctx.fill();
+        }
+
         // Sin restaurar contexto durante movimiento para máxima velocidad
       }
       return;
     }
     
     drawingPointsRef.current.push(x, y);
   };
 
   const handleMouseUp = () => {
     setIsDrawing(false);
     setIsPanning(false);
 
     if (currentLineRef.current) {
       const newLine = { ...currentLineRef.current, points: [...drawingPointsRef.current] };
       if (currentLineRef.current.layer === 'drawing') {
         setDrawingLines(prev => [...prev, newLine]);
       } else {
         setStencilLines(prev => [...prev, newLine]);
       }
     }
     cancelAnimationFrame(frameRef.current);
     drawingPointsRef.current = [];
     currentLineRef.current = null;
 
     // Finalizar borrado de stencil con restauración del contexto
