diff --git a/client/src/components/StencilEditor/StencilEditor.tsx b/client/src/components/StencilEditor/StencilEditor.tsx
index bcb34fd0ff4343e955c6963ff4c15d1cb6baab3c..b02d9c7fa342d7e5d562a03054694420ebd11e7d 100644
--- a/client/src/components/StencilEditor/StencilEditor.tsx
+++ b/client/src/components/StencilEditor/StencilEditor.tsx
@@ -1,42 +1,43 @@
 import React, { useState, useRef, useEffect } from 'react';
 import { Stage, Layer, Image as KonvaImage, Line } from 'react-konva';
 import { Button } from '@/components/ui/button';
 import { Slider } from '@/components/ui/slider';
 import { Sheet, SheetContent, SheetTrigger, SheetTitle } from '@/components/ui/sheet';
 import { Switch } from '@/components/ui/switch';
 import { 
   PenTool, 
   Eraser, 
   Layers, 
   GripVertical,
   ArrowLeft,
   Eye,
   EyeOff,
   Move
 } from 'lucide-react';
 import { useLocation } from 'wouter';
+import { rgbToHsl, hslToRgb } from '@/lib/color';
 
 // Colores disponibles para el dibujo - solo negro, rojo y azul
 const DRAWING_COLORS = [
   '#000000', // Negro
   '#ef4444', // Rojo
   '#3b82f6', // Azul
 ];
 
 // Hook personalizado para manejar la l칩gica del canvas
 function useStencilCanvas() {
   const [tool, setTool] = useState<'brush' | 'eraser' | 'move'>('brush');
   const [brushSize, setBrushSize] = useState(4);
   const [eraserSize, setEraserSize] = useState(10);
   const [activeLayer, setActiveLayer] = useState<'drawing' | 'stencil'>('drawing');
   const [brushColor, setBrushColor] = useState('#ef4444'); // Rojo por defecto
   const [stencilHue, setStencilHue] = useState(0); // Control de tono para stencil
   const [layers, setLayers] = useState({
     drawing: { visible: true, opacity: 100 },
     stencil: { visible: true, opacity: 100 },
     original: { visible: true, opacity: 20 }
   });
   const [viewTransform, setViewTransform] = useState({
     x: 0,
     y: 0,
     scale: 1
diff --git a/client/src/components/StencilEditor/StencilEditor.tsx b/client/src/components/StencilEditor/StencilEditor.tsx
index bcb34fd0ff4343e955c6963ff4c15d1cb6baab3c..b02d9c7fa342d7e5d562a03054694420ebd11e7d 100644
--- a/client/src/components/StencilEditor/StencilEditor.tsx
+++ b/client/src/components/StencilEditor/StencilEditor.tsx
@@ -197,94 +198,50 @@ export default function StencilEditor({ originalImage, stencilImage }: StencilEd
             // Aplicar cambio de tono
             const newH = (h + stencilHue / 360) % 1;
             
             // Convertir de vuelta a RGB
             const [newR, newG, newB] = hslToRgb(newH, s, l);
             
             data[i] = newR;
             data[i + 1] = newG;
             data[i + 2] = newB;
           }
           
           // Aplicar datos modificados
           ctx.putImageData(imageData, 0, 0);
         }
         
         // Crear nueva imagen
         const newImg = new Image();
         newImg.onload = () => {
           setFilteredStencilImg(newImg);
         };
         newImg.src = canvas.toDataURL();
       }
     }
   }, [stencilImg, stencilHue]);
 
-  // Funciones de conversi칩n de color
-  const rgbToHsl = (r: number, g: number, b: number): [number, number, number] => {
-    r /= 255;
-    g /= 255;
-    b /= 255;
-    const max = Math.max(r, g, b);
-    const min = Math.min(r, g, b);
-    let h = 0, s = 0, l = (max + min) / 2;
-
-    if (max !== min) {
-      const d = max - min;
-      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
-      switch (max) {
-        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
-        case g: h = (b - r) / d + 2; break;
-        case b: h = (r - g) / d + 4; break;
-      }
-      h /= 6;
-    }
-    return [h, s, l];
-  };
-
-  const hslToRgb = (h: number, s: number, l: number): [number, number, number] => {
-    let r, g, b;
-    if (s === 0) {
-      r = g = b = l;
-    } else {
-      const hue2rgb = (p: number, q: number, t: number) => {
-        if (t < 0) t += 1;
-        if (t > 1) t -= 1;
-        if (t < 1/6) return p + (q - p) * 6 * t;
-        if (t < 1/2) return q;
-        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
-        return p;
-      };
-      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
-      const p = 2 * l - q;
-      r = hue2rgb(p, q, h + 1/3);
-      g = hue2rgb(p, q, h);
-      b = hue2rgb(p, q, h - 1/3);
-    }
-    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
-  };
-
   // Manejo de gestos t치ctiles y mouse
   const handleMouseDown = (e: any) => {
     const stage = e.target.getStage();
     const pos = stage.getPointerPosition();
     
     if (tool === 'move' || e.evt.button === 1 || e.evt.button === 2) { // Move tool, middle click or right click for panning
       e.evt.preventDefault();
       setIsPanning(true);
       setLastPointerPosition(pos);
       return;
     }
 
     if (tool === 'brush' || tool === 'eraser') {
       setIsDrawing(true);
       const adjustedPos = {
         x: (pos.x - viewTransform.x) / viewTransform.scale,
         y: (pos.y - viewTransform.y) / viewTransform.scale
       };
 
       // Si es borrador en capa stencil, preparar canvas para edici칩n
       if (tool === 'eraser' && activeLayer === 'stencil' && stencilImg) {
         setIsErasingStencil(true);
         
         // Crear canvas de trabajo si no existe
         if (!stencilCanvas) {
