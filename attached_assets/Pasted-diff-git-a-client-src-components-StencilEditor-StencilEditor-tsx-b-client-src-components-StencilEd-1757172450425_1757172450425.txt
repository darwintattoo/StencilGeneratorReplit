diff --git a/client/src/components/StencilEditor/StencilEditor.tsx b/client/src/components/StencilEditor/StencilEditor.tsx
index bcb34fd0ff4343e955c6963ff4c15d1cb6baab3c..98532b12174c6d7c48a8ba3778b08f0b3439e521 100644
--- a/client/src/components/StencilEditor/StencilEditor.tsx
+++ b/client/src/components/StencilEditor/StencilEditor.tsx
@@ -1,27 +1,30 @@
 import React, { useState, useRef, useEffect } from 'react';
 import { Stage, Layer, Image as KonvaImage, Line } from 'react-konva';
+import type { KonvaEventObject } from 'konva/lib/Node';
+import type { Stage as KonvaStage } from 'konva/lib/Stage';
+import type { Layer as KonvaLayer } from 'konva/lib/Layer';
 import { Button } from '@/components/ui/button';
 import { Slider } from '@/components/ui/slider';
 import { Sheet, SheetContent, SheetTrigger, SheetTitle } from '@/components/ui/sheet';
 import { Switch } from '@/components/ui/switch';
 import { 
   PenTool, 
   Eraser, 
   Layers, 
   GripVertical,
   ArrowLeft,
   Eye,
   EyeOff,
   Move
 } from 'lucide-react';
 import { useLocation } from 'wouter';
 
 // Colores disponibles para el dibujo - solo negro, rojo y azul
 const DRAWING_COLORS = [
   '#000000', // Negro
   '#ef4444', // Rojo
   '#3b82f6', // Azul
 ];
 
 // Hook personalizado para manejar la lógica del canvas
 function useStencilCanvas() {
diff --git a/client/src/components/StencilEditor/StencilEditor.tsx b/client/src/components/StencilEditor/StencilEditor.tsx
index bcb34fd0ff4343e955c6963ff4c15d1cb6baab3c..98532b12174c6d7c48a8ba3778b08f0b3439e521 100644
--- a/client/src/components/StencilEditor/StencilEditor.tsx
+++ b/client/src/components/StencilEditor/StencilEditor.tsx
@@ -79,62 +82,72 @@ function useStencilCanvas() {
     setViewTransform({ x: 0, y: 0, scale: 1 });
   };
 
   return {
     tool,
     setTool,
     brushSize,
     setBrushSize,
     eraserSize,
     setEraserSize,
     activeLayer,
     setActiveLayer,
     brushColor,
     setBrushColor,
     stencilHue,
     setStencilHue,
     layers,
     toggleLayer,
     setOpacity,
     viewTransform,
     handleGesture,
     resetView
   };
 }
 
+interface DrawingLine {
+  tool: 'brush' | 'eraser';
+  points: number[];
+  strokeWidth: number;
+  layer: 'drawing' | 'stencil';
+  color: string;
+  globalCompositeOperation?: 'source-over' | 'destination-out';
+}
+
 interface StencilEditorProps {
   originalImage?: string;
   stencilImage?: string;
+  onSave?: (editedImageUrl: string) => Promise<void>;
 }
 
 export default function StencilEditor({ originalImage, stencilImage }: StencilEditorProps) {
   const [location, setLocation] = useLocation();
-  const stageRef = useRef<any>(null);
+  const stageRef = useRef<KonvaStage | null>(null);
   const [originalImg, setOriginalImg] = useState<HTMLImageElement | null>(null);
   const [stencilImg, setStencilImg] = useState<HTMLImageElement | null>(null);
   const [isDrawing, setIsDrawing] = useState(false);
-  const [lines, setLines] = useState<any[]>([]);
+  const [lines, setLines] = useState<DrawingLine[]>([]);
   const [nativeSize, setNativeSize] = useState({ width: 800, height: 600 });
   const [isPanning, setIsPanning] = useState(false);
   const [lastPointerPosition, setLastPointerPosition] = useState({ x: 0, y: 0 });
   const [isLayersOpen, setIsLayersOpen] = useState(false);
   const [touches, setTouches] = useState<Touch[]>([]);
   const [lastPinchDistance, setLastPinchDistance] = useState(0);
   const [lastTouchCenter, setLastTouchCenter] = useState({ x: 0, y: 0 });
   const [stencilCanvas, setStencilCanvas] = useState<HTMLCanvasElement | null>(null);
   const [isErasingStencil, setIsErasingStencil] = useState(false);
   const [filteredStencilImg, setFilteredStencilImg] = useState<HTMLImageElement | null>(null);
 
   const {
     tool,
     setTool,
     brushSize,
     setBrushSize,
     eraserSize,
     setEraserSize,
     activeLayer,
     setActiveLayer,
     brushColor,
     setBrushColor,
     stencilHue,
     setStencilHue,
     layers,
diff --git a/client/src/components/StencilEditor/StencilEditor.tsx b/client/src/components/StencilEditor/StencilEditor.tsx
index bcb34fd0ff4343e955c6963ff4c15d1cb6baab3c..98532b12174c6d7c48a8ba3778b08f0b3439e521 100644
--- a/client/src/components/StencilEditor/StencilEditor.tsx
+++ b/client/src/components/StencilEditor/StencilEditor.tsx
@@ -242,114 +255,127 @@ export default function StencilEditor({ originalImage, stencilImage }: StencilEd
   };
 
   const hslToRgb = (h: number, s: number, l: number): [number, number, number] => {
     let r, g, b;
     if (s === 0) {
       r = g = b = l;
     } else {
       const hue2rgb = (p: number, q: number, t: number) => {
         if (t < 0) t += 1;
         if (t > 1) t -= 1;
         if (t < 1/6) return p + (q - p) * 6 * t;
         if (t < 1/2) return q;
         if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
         return p;
       };
       const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
       const p = 2 * l - q;
       r = hue2rgb(p, q, h + 1/3);
       g = hue2rgb(p, q, h);
       b = hue2rgb(p, q, h - 1/3);
     }
     return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
   };
 
   // Manejo de gestos táctiles y mouse
-  const handleMouseDown = (e: any) => {
+  const handleMouseDown = (
+    e: KonvaEventObject<MouseEvent | TouchEvent>
+  ) => {
     const stage = e.target.getStage();
+    if (!stage) return;
     const pos = stage.getPointerPosition();
+    if (!pos) return;
     
-    if (tool === 'move' || e.evt.button === 1 || e.evt.button === 2) { // Move tool, middle click or right click for panning
+    if (
+      tool === 'move' ||
+      ('button' in e.evt && (e.evt.button === 1 || e.evt.button === 2))
+    ) {
+      // Move tool, middle click or right click for panning
       e.evt.preventDefault();
       setIsPanning(true);
       setLastPointerPosition(pos);
       return;
     }
 
     if (tool === 'brush' || tool === 'eraser') {
       setIsDrawing(true);
       const adjustedPos = {
         x: (pos.x - viewTransform.x) / viewTransform.scale,
         y: (pos.y - viewTransform.y) / viewTransform.scale
       };
 
       // Si es borrador en capa stencil, preparar canvas para edición
       if (tool === 'eraser' && activeLayer === 'stencil' && stencilImg) {
         setIsErasingStencil(true);
         
         // Crear canvas de trabajo si no existe
         if (!stencilCanvas) {
           const canvas = document.createElement('canvas');
           canvas.width = stencilImg.width;
           canvas.height = stencilImg.height;
           const ctx = canvas.getContext('2d');
           if (ctx) {
             ctx.drawImage(stencilImg, 0, 0);
             setStencilCanvas(canvas);
           }
         }
         
         // Aplicar borrado inicial
         if (stencilCanvas) {
           const ctx = stencilCanvas.getContext('2d');
           if (ctx) {
             ctx.save();
             ctx.globalCompositeOperation = 'destination-out';
             ctx.beginPath();
             ctx.arc(adjustedPos.x, adjustedPos.y, eraserSize, 0, 2 * Math.PI);
             ctx.fill();
             ctx.restore();
           }
         }
         return;
       }
       
-      const newLine = {
+      const newLine: DrawingLine = {
         tool,
         points: [adjustedPos.x, adjustedPos.y],
         strokeWidth: tool === 'brush' ? brushSize : eraserSize,
-        globalCompositeOperation: tool === 'eraser' ? 'destination-out' : 'source-over',
+        globalCompositeOperation:
+          tool === 'eraser' ? 'destination-out' : 'source-over',
         layer: activeLayer,
         color: tool === 'brush' ? brushColor : '#ffffff'
       };
       setLines([...lines, newLine]);
     }
   };
 
-  const handleMouseMove = (e: any) => {
+  const handleMouseMove = (
+    e: KonvaEventObject<MouseEvent | TouchEvent>
+  ) => {
     const stage = e.target.getStage();
+    if (!stage) return;
     const pos = stage.getPointerPosition();
+    if (!pos) return;
 
     if (isPanning) {
       const deltaX = pos.x - lastPointerPosition.x;
       const deltaY = pos.y - lastPointerPosition.y;
       handleGesture('pan', { deltaX, deltaY });
       setLastPointerPosition(pos);
       return;
     }
 
     if (!isDrawing) return;
     
     const adjustedPos = {
       x: (pos.x - viewTransform.x) / viewTransform.scale,
       y: (pos.y - viewTransform.y) / viewTransform.scale
     };
 
     // Si es borrador en capa stencil, usar técnica de borrado inmediato ultra-rápido
     if (tool === 'eraser' && activeLayer === 'stencil' && stencilCanvas && isErasingStencil) {
       const ctx = stencilCanvas.getContext('2d');
       
       if (ctx) {
         // Borrado inmediato sin operaciones bloqueantes
         ctx.globalCompositeOperation = 'destination-out';
         ctx.fillStyle = '#000';
         
diff --git a/client/src/components/StencilEditor/StencilEditor.tsx b/client/src/components/StencilEditor/StencilEditor.tsx
index bcb34fd0ff4343e955c6963ff4c15d1cb6baab3c..98532b12174c6d7c48a8ba3778b08f0b3439e521 100644
--- a/client/src/components/StencilEditor/StencilEditor.tsx
+++ b/client/src/components/StencilEditor/StencilEditor.tsx
@@ -377,153 +403,155 @@ export default function StencilEditor({ originalImage, stencilImage }: StencilEd
     // Finalizar borrado de stencil con restauración del contexto
     if (isErasingStencil && stencilCanvas) {
       // Restaurar contexto una sola vez al final
       const ctx = stencilCanvas.getContext('2d');
       if (ctx) {
         ctx.globalCompositeOperation = 'source-over'; // Restaurar modo normal
       }
       
       // Actualización diferida para no bloquear
       setTimeout(() => {
         const newImg = new Image();
         newImg.onload = () => {
           setStencilImg(newImg);
           if (stencilHue !== 0) {
             setFilteredStencilImg(null);
           }
         };
         newImg.src = stencilCanvas.toDataURL();
       }, 0);
       setIsErasingStencil(false);
     }
     
     if (tool === 'eraser' && stageRef.current) {
       setTimeout(() => {
         if (stageRef.current) {
-          const layers = stageRef.current.find('Layer');
-          layers.forEach((layer: any) => {
+          const layers = stageRef.current.find('Layer') as KonvaLayer[];
+          layers.forEach(layer => {
             try {
               const hitCanvas = layer.getHitCanvas();
               if (hitCanvas) {
-                const hitContext = hitCanvas.getContext('2d');
+                const hitContext = hitCanvas.getContext();
                 hitContext.clearRect(0, 0, nativeSize.width, nativeSize.height);
-                layer.clearHitCache();
+                (layer as any).clearHitCache?.();
               }
             } catch (e) {
               console.log('Error limpiando hit canvas:', e);
             }
             layer.batchDraw();
           });
           stageRef.current.batchDraw();
         }
       }, 50);
     }
   };
 
-  const handleWheel = (e: any) => {
+  const handleWheel = (e: KonvaEventObject<WheelEvent>) => {
     e.evt.preventDefault();
     const scaleBy = 1.1;
     const stage = e.target.getStage();
+    if (!stage) return;
     const oldScale = viewTransform.scale;
     const pointer = stage.getPointerPosition();
+    if (!pointer) return;
 
     const newScale = e.evt.deltaY > 0 ? oldScale / scaleBy : oldScale * scaleBy;
     handleGesture('pinch', {
       scale: Math.max(0.1, Math.min(5, newScale)),
       centerX: pointer.x,
       centerY: pointer.y
     });
   };
 
   // Funciones para gestos táctiles
   const getDistance = (touch1: Touch, touch2: Touch) => {
     const dx = touch1.clientX - touch2.clientX;
     const dy = touch1.clientY - touch2.clientY;
     return Math.sqrt(dx * dx + dy * dy);
   };
 
   const getCenter = (touch1: Touch, touch2: Touch) => {
     return {
       x: (touch1.clientX + touch2.clientX) / 2,
       y: (touch1.clientY + touch2.clientY) / 2
     };
   };
 
-  const handleTouchStart = (e: any) => {
+  const handleTouchStart = (e: KonvaEventObject<TouchEvent>) => {
     const touchList = Array.from(e.evt.touches) as Touch[];
     setTouches(touchList);
 
     if (touchList.length === 2) {
       // Inicio de pinch
       const distance = getDistance(touchList[0], touchList[1]);
       const center = getCenter(touchList[0], touchList[1]);
       setLastPinchDistance(distance);
       setLastTouchCenter(center);
       setIsPanning(false);
       setIsDrawing(false);
     } else if (touchList.length === 1) {
       // Toque único - dibujo o pan
       handleMouseDown(e);
     }
   };
 
-  const handleTouchMove = (e: any) => {
+  const handleTouchMove = (e: KonvaEventObject<TouchEvent>) => {
     e.evt.preventDefault();
     const touchList = Array.from(e.evt.touches) as Touch[];
 
     if (touchList.length === 2) {
       // Pinch zoom y pan con dos dedos
       const distance = getDistance(touchList[0], touchList[1]);
       const center = getCenter(touchList[0], touchList[1]);
 
       if (lastPinchDistance > 0) {
         // Zoom
         const scale = distance / lastPinchDistance;
         const newScale = Math.max(0.1, Math.min(5, viewTransform.scale * scale));
         
         // Pan
         const deltaX = center.x - lastTouchCenter.x;
         const deltaY = center.y - lastTouchCenter.y;
 
         handleGesture('pinch', {
           scale: newScale,
           centerX: center.x,
           centerY: center.y
         });
 
         handleGesture('pan', { deltaX, deltaY });
       }
 
       setLastPinchDistance(distance);
       setLastTouchCenter(center);
     } else if (touchList.length === 1 && (tool === 'brush' || tool === 'eraser') && isDrawing) {
       // Dibujo con un dedo
       handleMouseMove(e);
     }
   };
 
-  const handleTouchEnd = (e: any) => {
+  const handleTouchEnd = (e: KonvaEventObject<TouchEvent>) => {
     const touchList = Array.from(e.evt.touches) as Touch[];
     setTouches(touchList);
 
     if (touchList.length < 2) {
       setLastPinchDistance(0);
     }
 
     if (touchList.length === 0) {
       handleMouseUp();
     }
   };
 
   // Doble tap para reset
   const handleDoubleTap = () => {
     resetView();
   };
 
   return (
     <div className="h-screen bg-gray-100 relative flex">
       {/* Canvas principal */}
       <div className="flex-1 relative">
         <Stage
           width={window.innerWidth - (isLayersOpen ? 320 : 0)}
           height={window.innerHeight}
           onMouseDown={handleMouseDown}
