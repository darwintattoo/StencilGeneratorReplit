diff --git a/client/src/components/StencilEditor/StencilEditor.tsx b/client/src/components/StencilEditor/StencilEditor.tsx
index 08d0002581831b066b3e4f58e4d43da6a7f7024b..71d18a01f3e25b01b5b8a87dcb7590dddb159d1f 100644
--- a/client/src/components/StencilEditor/StencilEditor.tsx
+++ b/client/src/components/StencilEditor/StencilEditor.tsx
@@ -140,51 +140,51 @@ export default function StencilEditor({ originalImage, stencilImage }: StencilEd
   const [isDrawing, setIsDrawing] = useState<boolean>(false);
   const [drawingLines, setDrawingLines] = useState<DrawingLine[]>([]);
   const [stencilLines, setStencilLines] = useState<DrawingLine[]>([]);
   const drawingPointsRef = useRef<number[]>([]);
   const currentLineRef = useRef<DrawingLine | null>(null);
   const frameRef = useRef<number>(0);
   const tempLineRef = useRef<LineRef>(null);
 
   const updateTempLine = () => {
     if (tempLineRef.current) {
       tempLineRef.current.points(drawingPointsRef.current);
       tempLineRef.current.getLayer()?.batchDraw();
     }
     frameRef.current = requestAnimationFrame(updateTempLine);
   };
   const [nativeSize, setNativeSize] = useState<NativeSize>({ width: 800, height: 600 });
   const [isPanning, setIsPanning] = useState<boolean>(false);
   const [lastPointerPosition, setLastPointerPosition] = useState<Position>({ x: 0, y: 0 });
   const [isLayersOpen, setIsLayersOpen] = useState<boolean>(false);
   const touchesRef = useRef<Touch[]>([]);
   const lastPinchDistanceRef = useRef<number>(0);
   const lastTouchCenterRef = useRef<TouchCenter>({ x: 0, y: 0 });
   const lastAngleRef = useRef<number>(0);
   const [stencilCanvas, setStencilCanvas] = useState<HTMLCanvasElement | null>(null);
   const [isErasingStencil, setIsErasingStencil] = useState<boolean>(false);
-  const [filteredStencilImg, setFilteredStencilImg] = useState<HTMLImageElement | null>(null);
+  const [filteredStencilImg, setFilteredStencilImg] = useState<HTMLCanvasElement | null>(null);
   const [canvasSize, setCanvasSize] = useState<NativeSize>({ 
     width: window.innerWidth, 
     height: window.innerHeight 
   });
 
   const {
     tool,
     setTool,
     brushSize,
     setBrushSize,
     eraserSize,
     setEraserSize,
     activeLayer,
     setActiveLayer,
     brushColor,
     setBrushColor,
     stencilHue,
     setStencilHue,
     layers,
     toggleLayer,
     setOpacity,
     viewTransform,
     handleGesture,
     resetView
   } = useStencilCanvas();
diff --git a/client/src/components/StencilEditor/StencilEditor.tsx b/client/src/components/StencilEditor/StencilEditor.tsx
index 08d0002581831b066b3e4f58e4d43da6a7f7024b..71d18a01f3e25b01b5b8a87dcb7590dddb159d1f 100644
--- a/client/src/components/StencilEditor/StencilEditor.tsx
+++ b/client/src/components/StencilEditor/StencilEditor.tsx
@@ -207,127 +207,163 @@ export default function StencilEditor({ originalImage, stencilImage }: StencilEd
     };
   }, []);
 
   // Cargar imágenes en resolución nativa
   useEffect(() => {
     if (stencilImage) {
       const img = new window.Image();
       img.crossOrigin = 'anonymous';
       img.onload = () => {
         setStencilImg(img);
         setNativeSize({ width: img.width, height: img.height });
       };
       img.src = stencilImage;
     }
   }, [stencilImage]);
 
   useEffect(() => {
     if (originalImage) {
       const img = new window.Image();
       img.crossOrigin = 'anonymous';
       img.onload = () => setOriginalImg(img);
       img.src = originalImage;
     }
   }, [originalImage]);
 
+  const pickColorAt = (x: number, y: number): string | null => {
+    let source: HTMLCanvasElement | null = stencilCanvas || filteredStencilImg;
+    if (!source && stencilImg) {
+      source = document.createElement('canvas');
+      source.width = stencilImg.width;
+      source.height = stencilImg.height;
+      const tempCtx = source.getContext('2d');
+      tempCtx?.drawImage(stencilImg, 0, 0);
+    }
+    if (!source) return null;
+    const ctx = source.getContext('2d');
+    if (!ctx) return null;
+    const { data } = ctx.getImageData(x, y, 1, 1);
+    const [r, g, b] = data;
+    return `rgb(${r}, ${g}, ${b})`;
+  };
+
+  const applyHue = (canvas: HTMLCanvasElement, hue: number) => {
+    const ctx = canvas.getContext('2d');
+    if (!ctx) return;
+    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
+    const data = imageData.data;
+    for (let i = 0; i < data.length; i += 4) {
+      const r = data[i];
+      const g = data[i + 1];
+      const b = data[i + 2];
+      const [h, s, l] = rgbToHsl(r, g, b);
+      const newH = (h + hue / 360) % 1;
+      const [newR, newG, newB] = hslToRgb(newH, s, l);
+      data[i] = newR;
+      data[i + 1] = newG;
+      data[i + 2] = newB;
+    }
+    ctx.putImageData(imageData, 0, 0);
+  };
+
   // Aplicar filtro de tono al stencil
   useEffect(() => {
     if (stencilImg) {
       const canvas = document.createElement('canvas');
       const ctx = canvas.getContext('2d');
-      
+
       if (ctx) {
         canvas.width = stencilImg.width;
         canvas.height = stencilImg.height;
-        
+
         // Dibujar imagen original
         ctx.drawImage(stencilImg, 0, 0);
-        
+
         if (stencilHue !== 0) {
-          // Obtener datos de píxeles
-          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
-          const data = imageData.data;
-          
-          // Aplicar transformación de tono
-          for (let i = 0; i < data.length; i += 4) {
-            const r = data[i];
-            const g = data[i + 1];
-            const b = data[i + 2];
-            
-            // Convertir RGB a HSL
-            const [h, s, l] = rgbToHsl(r, g, b);
-            
-            // Aplicar cambio de tono
-            const newH = (h + stencilHue / 360) % 1;
-            
-            // Convertir de vuelta a RGB
-            const [newR, newG, newB] = hslToRgb(newH, s, l);
-            
-            data[i] = newR;
-            data[i + 1] = newG;
-            data[i + 2] = newB;
+          applyHue(canvas, stencilHue);
+        }
+
+        // Actualizar canvas del stencil o crear uno nuevo
+        let targetCanvas = stencilCanvas;
+        if (targetCanvas) {
+          const tctx = targetCanvas.getContext('2d');
+          if (tctx) {
+            targetCanvas.width = canvas.width;
+            targetCanvas.height = canvas.height;
+            tctx.clearRect(0, 0, canvas.width, canvas.height);
+            tctx.drawImage(canvas, 0, 0);
           }
-          
-          // Aplicar datos modificados
-          ctx.putImageData(imageData, 0, 0);
+        } else {
+          targetCanvas = document.createElement('canvas');
+          targetCanvas.width = canvas.width;
+          targetCanvas.height = canvas.height;
+          const tctx = targetCanvas.getContext('2d');
+          tctx?.drawImage(canvas, 0, 0);
+          setStencilCanvas(targetCanvas);
         }
-        
-        // Crear nueva imagen
-        const newImg = new Image();
-        newImg.onload = () => {
-          setFilteredStencilImg(newImg);
-        };
-        newImg.src = canvas.toDataURL();
+
+        // Usar el canvas resultante como imagen filtrada
+        setFilteredStencilImg(stencilHue !== 0 ? targetCanvas || null : null);
       }
     }
+    // eslint-disable-next-line react-hooks/exhaustive-deps
   }, [stencilImg, stencilHue]);
 
   // Manejo de gestos táctiles y mouse
   const handleMouseDown = (e: KonvaMouseEvent | KonvaTouchEvent) => {
     const stage = stageRef.current;
     if (!stage) return;
     const pos = stage.getPointerPosition();
     if (!pos) return;
     
     const mouseEvent = e.evt as MouseEvent;
     if (tool === 'move' || mouseEvent.button === 1 || mouseEvent.button === 2) { // Move tool, middle click or right click for panning
       e.evt.preventDefault();
       setIsPanning(true);
       setLastPointerPosition(pos);
       return;
     }
 
     if (tool === 'brush' || tool === 'eraser') {
       // Ignorar gestos de dibujo/borrado si el pointerType es 'touch'
       const pointerEvent = e.evt as any;
       if (pointerEvent.pointerType === 'touch') {
         return;
       }
-      setIsDrawing(true);
       const transform = stage.getAbsoluteTransform().copy().invert();
       const { x, y } = transform.point(pos);
 
+      if (mouseEvent.altKey) {
+        const picked = pickColorAt(x, y);
+        if (picked) {
+          setBrushColor(picked);
+        }
+        return;
+      }
+
+      setIsDrawing(true);
+
       // Si es borrador en capa stencil, preparar canvas para edición
       if (tool === 'eraser' && activeLayer === 'stencil' && stencilImg) {
         setIsErasingStencil(true);
         
         // Crear canvas de trabajo si no existe
         if (!stencilCanvas) {
           const canvas = document.createElement('canvas');
           canvas.width = stencilImg.width;
           canvas.height = stencilImg.height;
           const ctx = canvas.getContext('2d');
           if (ctx) {
             ctx.drawImage(stencilImg, 0, 0);
             setStencilCanvas(canvas);
           }
         }
         
         // Aplicar borrado inicial
         if (stencilCanvas) {
           const ctx = stencilCanvas.getContext('2d');
           if (ctx) {
             ctx.save();
             ctx.globalCompositeOperation = 'destination-out';
             ctx.beginPath();
             ctx.arc(x, y, eraserSize, 0, 2 * Math.PI);
             ctx.fill();
diff --git a/client/src/components/StencilEditor/StencilEditor.tsx b/client/src/components/StencilEditor/StencilEditor.tsx
index 08d0002581831b066b3e4f58e4d43da6a7f7024b..71d18a01f3e25b01b5b8a87dcb7590dddb159d1f 100644
--- a/client/src/components/StencilEditor/StencilEditor.tsx
+++ b/client/src/components/StencilEditor/StencilEditor.tsx
@@ -406,52 +442,57 @@ export default function StencilEditor({ originalImage, stencilImage }: StencilEd
     if (currentLineRef.current) {
       const newLine = { ...currentLineRef.current, points: [...drawingPointsRef.current] };
       if (currentLineRef.current.layer === 'drawing') {
         setDrawingLines(prev => [...prev, newLine]);
       } else {
         setStencilLines(prev => [...prev, newLine]);
       }
     }
     cancelAnimationFrame(frameRef.current);
     drawingPointsRef.current = [];
     currentLineRef.current = null;
 
     // Finalizar borrado de stencil con restauración del contexto
     if (isErasingStencil && stencilCanvas) {
       // Restaurar contexto una sola vez al final
       const ctx = stencilCanvas.getContext('2d');
       if (ctx) {
         ctx.globalCompositeOperation = 'source-over'; // Restaurar modo normal
       }
       
       // Actualización diferida para no bloquear
       setTimeout(() => {
         const newImg = new Image();
         newImg.onload = () => {
           setStencilImg(newImg);
-          if (stencilHue !== 0) {
-            setFilteredStencilImg(null);
+          if (stencilCanvas) {
+            if (stencilHue !== 0) {
+              applyHue(stencilCanvas, stencilHue);
+              setFilteredStencilImg(stencilCanvas);
+            } else {
+              setFilteredStencilImg(null);
+            }
           }
         };
         newImg.src = stencilCanvas.toDataURL();
       }, 0);
       setIsErasingStencil(false);
     }
     
     if (tool === 'eraser' && stageRef.current) {
       setTimeout(() => {
         if (stageRef.current) {
           const layers = stageRef.current.find('Layer');
           layers.forEach((layer: any) => {
             try {
               const hitCanvas = layer.getHitCanvas();
               if (hitCanvas) {
                 const hitContext = hitCanvas.getContext('2d');
                 hitContext.clearRect(0, 0, nativeSize.width, nativeSize.height);
                 layer.clearHitCache();
               }
             } catch (e) {
               console.log('Error limpiando hit canvas:', e);
             }
             layer.batchDraw();
           });
           stageRef.current.batchDraw();
