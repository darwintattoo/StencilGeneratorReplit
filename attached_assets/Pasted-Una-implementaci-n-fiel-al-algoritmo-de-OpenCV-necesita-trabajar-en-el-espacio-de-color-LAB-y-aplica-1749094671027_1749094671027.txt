Una implementación fiel al algoritmo de OpenCV necesita trabajar en el espacio de color LAB y aplicar CLAHE con la función nativa de la librería. Actualmente server/image-processing.ts calcula los tiles y la luminancia manualmente:

const tileWidth = Math.floor(width / tileGridSize);
const tileHeight = Math.floor(height / tileGridSize);
// ...
processTileWithCLAHE(data, processedData, startX, startY, endX, endY, width, info.channels, clipLimit);

y la luminancia se estima con la fórmula RGB → Y:

const luminance = Math.round(0.299 * r + 0.587 * g + 0.114 * b);

Para obtener resultados equivalentes a OpenCV, se recomienda usar opencv4nodejs (u otra librería que exponga la función CLAHE real). Los pasos serían:

Instalar la dependencia

npm install opencv4nodejs
(Es necesario tener OpenCV instalado en el sistema).

Reescribir applyCLAHE utilizando la implementación de OpenCV

// server/image-processing.ts
import cv from 'opencv4nodejs';
import path from 'path';

export async function applyCLAHE(
  imagePath: string,
  clipLimit = 2.0,
  tileGridSize = 8
): Promise<string> {
  const ext = path.extname(imagePath);
  const basename = path.basename(imagePath, ext);
  const outputPath = path.join(path.dirname(imagePath), `${basename}_clahe${ext}`);

  // Leer imagen en BGR
  const img = await cv.imreadAsync(imagePath);

  // Convertir a LAB y separar canales
  const lab = img.cvtColor(cv.COLOR_BGR2Lab);
  const [l, a, b] = lab.split();

  // Crear CLAHE y aplicarlo sobre L
  const clahe = new cv.CLAHE(clipLimit, new cv.Size(tileGridSize, tileGridSize));
  const lEqualized = clahe.apply(l);

  // Unir canales y volver a RGB
  const labMerged = new cv.Mat([lEqualized, a, b]).merge();
  const resultBGR = labMerged.cvtColor(cv.COLOR_Lab2BGR);

  await cv.imwriteAsync(outputPath, resultBGR);
  return outputPath;
}
Invocar esta función en applyAutoExposureCorrection tal y como ya se hace, para luego enviar la imagen procesada a ComfyDeploy.

Con este cambio, el procesamiento de exposición será idéntico al que ofrece OpenCV, corrigiendo de manera más precisa (y no solo variando brillo y contraste) antes de enviar la imagen a la API externa.


